---
title: "03) Differentialy Co-Expressed Network"
author: "Mattia Manna"
date: "`r Sys.Date()`"
output:
  pdf_document: 
    latex_engine: xelatex
    number_sections: true 
header-includes:
- \usepackage{bbold}
- \usepackage{mdframed, xcolor}
- \mdfsetup{frametitlealignment=\center}
- \usepackage{graphicx}
---


\pagenumbering{Roman}
\renewcommand*\contentsname{Indice}
\tableofcontents

```{r include=FALSE,eval=FALSE}
# Pacchetti da installare per far funzionare WGCNA
BiocManager::install("GO.db")
BiocManager::install("impute")
BiocManager::install("preprocessCore")
```



\newpage
\pagenumbering{arabic}

```{r libraries, include=FALSE}
library(edgeR)
library(purrr)
library(WGCNA)
library(ggplot2)
library(network)  # work with graphs
library(ggnet)
```



```{r import data, include=FALSE}
rm(list = ls(all.names = TRUE))
load("/Users/mattia/Desktop/Università/Magistrale/Tesi/R/Replica Tesi/01) Filtered_data.RData")
load("/Users/mattia/Desktop/Università/Magistrale/Tesi/R/Replica Tesi/02) DEGs.RData")
```

```{r import functions, include=FALSE}
load("/Users/mattia/Desktop/Università/Magistrale/Tesi/R/Replica Tesi/00) Funzioni.RData")
```



```{r ,include=FALSE}
# Salva tutti i dati importati per poi eliminarli prima di esportarli
# In questo modo ogni file di load di ogni script contiene solo i dati creati da lui
# permettendo, ad esempio, di aggiungere funzioni in  00 senza il bisogno di runnare di nuovo  i file 01 e 02
# Senza di questa  linea e la linea do.call(rm, as.list(imported.data)) alla fine dello script, infatti, 
# gli script 01 e 02 salvavano le loro copie delle funzioni che rimanevano vecchie se si 
# modificano le funzioni in 00 senza runnare 01 e 02 nuovamente causando gravi errori.
imported.data <- ls()
```



#  Pancancer vs HC differential co-expression network

## differential co-expression network tramite sintassi di Ali

### Calcolare gli zscores 


```{r}
# Estrarre il tep.expr.filtr dataframe normalizzato contenente solo  i DEGs
DEGS.tep.expr.filtr.normalized.pancancerVShc <- output.degs_extraction.pancancerVShc$DEGS.tep.expr.filtr.normalized


matrix.condition1 <- DEGS.tep.expr.filtr.normalized.pancancerVShc[, colnames(tep.expr.filtr.pancancer)]
matrix.condition2 <- DEGS.tep.expr.filtr.normalized.pancancerVShc[, colnames(tep.expr.filtr.hc)]
Zscores.pancancerVShc <- evaluate_zscores(matrix.condition1,matrix.condition2)
```



### Calcolare il differential co-expression network


```{r warning=F}
# Soglia
z_threshold <- 3

output.pancancerVShc <- differential_coexpression_network(Zscores.pancancerVShc,z_threshold)
```



### Degree distribution 

Si veda la degree distribution del differential co-expression network.    


```{r echo=FALSE}
hist(output.pancancerVShc$all_degree$degree,xlab="degree", main="Degree distribution",)
```

Esistono hubs, si proceda.

### Grafici e info 

```{r warning=FALSE,message=FALSE}
# Tramite titoli specificare se si vogliono o meno i titoli sui grafici.
info_grafo(output.pancancerVShc,titoli = T) # titoli=T ci sono i titoli.
```




\newpage
### Ottenere informazioni sugli hubs

Richiamando la funzione **info_hubs** vengono unite diverse informazioni riguardanti gli hubs.      
In questo modo si avranno informazioni più precise sugli hubs.    


```{r}
# Richiamare la funzione
output.info_hubs <- info_hubs(output.pancancerVShc$hubs,
                              output.degs_extraction.pancancerVShc$DEGs.metriche)

# Estrarre tutte le informazioni disponibili sugli hubs
hubs.info.pancancerVShc <- output.info_hubs$all.hubs.info

# Estrarre la versione ridotta, solo informazioni più utili
hubs.shortinfo.pancancerVShc <- output.info_hubs$short.hubs.info
```



Si veda un estratto delle informazioni più utili raccolte sugli hubs.   


```{r echo=FALSE}
hubs.shortinfo.pancancerVShc[1:4,1:6]
```




\newpage
## Differential co-expression network tramite DiffCor


Library [DiffCorr](https://cran.rstudio.com/web/packages/DiffCorr/vignettes/DiffCorr.html#export-the-results-fdr-0.05), https://cran.rstudio.com/web/packages/DiffCorr/vignettes/DiffCorr.html#export-the-results-fdr-0.05


Articolo su [DiffCorr](https://www.sciencedirect.com/science/article/pii/S0378111912014497), https://www.sciencedirect.com/science/article/pii/S0378111912014497


```{r warning=FALSE,message=FALSE,include=FALSE}
library(DiffCorr)
```


Lo scopo di questa sezione è quella di costruire un nuovo differential co-expression network
utilizzando i risultati del pacchetto **DiffCorr**.   
Si fa questo perchè si sta cercando di capire se questo nuovo network sia uguale a quello calcolato precedentemente.    



### Applicazione funzione **comp.2.cc.fdr**


Utilizzare la funzione **comp.2.cc.fdr** per il calcolo di:

\begin{itemize}
  \item conditional correlation coefficients
  \item p-values of the correlation test
  \item difference of the correlations
  \item corresponding p-values
\end{itemize}

```{r}
out.diffcorr <- comp.2.cc.fdr(data1 = matrix.condition1,   ## Col-0 (17 samples)
                              data2 = matrix.condition2,  ## tt4 (20 samples)
                              method = "pearson",
                              p.adjust.methods = "BH", #  "local", "holm" "hochberg"
                                                       #  "hommel" "bonferroni" "BH" 
                                                       #   "BY" "fdr" "none"
                              threshold = 1, # threshold massimo
                              save = F)
dim(out.diffcorr)
```


Si veda un esempio di output del pacchetto **DiffCorr**.        

```{r echo=FALSE}
out.diffcorr[1,]
```

\newpage
### Calcolare i valori Z

Grazie all'output **out.diffcorr** si possono calcolare  i  valori  Z.    

```{r}
n1 <- ncol(matrix.condition1)
n2 <- ncol(matrix.condition2)

denominatore <- sqrt((1/ (n1-3)) +  (1/ (n2-3)))

out.diffcorr$z1 <- (1/2) * log( (1+ out.diffcorr$r1) / (1- out.diffcorr$r1))
out.diffcorr$z2 <- (1/2) * log( (1+ out.diffcorr$r2) / (1- out.diffcorr$r2))
out.diffcorr$Z  <- (out.diffcorr$z1 - out.diffcorr$z2)/denominatore
```


### Passare da un oggetto  **DiffCorr** ad una  matrice di zscores

Siccome lo scopo è quello di confrontare il nuovo network che verrà creato con i risultati di **DiffCorr** con quello 
precedente bisogna rimuovere i geni esclusi dalla procedura precedente.


```{r}
genes.names <- rownames(DEGS.tep.expr.filtr.normalized.pancancerVShc)
n.adj <- length(genes.names)

# Inizializzare una matrice di adiacenza e modificarla
zscores.diffcorr <- matrix(data = NA,nrow= n.adj, ncol =n.adj ) 
rownames(zscores.diffcorr) <- genes.names # Assegnare i nomi dei geni alle righe
colnames(zscores.diffcorr) <- genes.names # Assegnare i nomi dei geni alle colonne
diag(zscores.diffcorr) <- 0 # Porre tutti i valori sulla diagonali pari a zero

# Passare dall'oggetto out.diffcorr ad una matrice di zscores
for(i in 1:nrow(out.diffcorr)){
  gene1 <- out.diffcorr$`molecule X`[i]
  gene2 <- out.diffcorr$`molecule Y`[i]
  z <- out.diffcorr$Z[i]
  
  zscores.diffcorr[gene1,gene2] <- z
  zscores.diffcorr[gene2,gene1] <- z
}
```



\newpage
### Calcolare una nuova matrice di adiacenza 

Calcolare una nuova matrice di adiacenza utilizzando i nuovi **zscores**  derivati dall' output
del pacchetto **DiffCorr**.   

```{r}
z_threshold <- 3
adjacency.matrix.diffcorr <- ifelse(zscores.diffcorr >= (z_threshold), 1, 
                                    ifelse(zscores.diffcorr <= (-z_threshold), -1, 0))  

# Geni da escludere
genes.to.delete <- c(output.pancancerVShc$geni.esclusi)


# Rimuovere dalla lista di tutti gli ENSEBLE name dei DEGs quelli esclusi dalla precedente analisi
genes.names <- genes.names[-which(genes.names %in% genes.to.delete )]

adjacency.matrix.diffcorr <- adjacency.matrix.diffcorr[genes.names,genes.names]
dim(adjacency.matrix.diffcorr)
```

Creare il network:

```{r}
net <- network(adjacency.matrix.diffcorr, matrix.type="adjacency",ignore.eval = T, directed = F)
```


### Confrontare le due matrici

Per prima cosa confrontare le matrici zscores

```{r}
all.equal(zscores.diffcorr, Zscores.pancancerVShc)
```

Poi confrontare le adjacency.matrix

```{r}
all.equal(adjacency.matrix.diffcorr, output.pancancerVShc$adjacency.matrix)
```

La matrice  degli zscores e la  adjacency.matrix sono identiche per le due procedure.   








```{r include=FALSE,eval=FALSE}
do.call(rm, as.list(imported.data))
rm(imported.data)
save(list = ls(), file = "/Users/mattia/Desktop/Università/Magistrale/Tesi/R/Replica Tesi/03) DiffCoNet.RData")
```














